# Go言語

## 共通

### Go言語の特徴

- ネイティブコードにコンパイルされる。
- マルチプラットフォームで動作する。（OSの標準ライブラリにすら依存しない）
- オブジェクト指向を有さず、関数と構造体で記述する。
- 使用されていない`import`文や変数があると、厳密にコンパイルエラーを出す。

### ドキュメント

- [go.dev](https://go.dev/)
- [A Tour of Go](https://go-tour-jp.appspot.com/list)
- [他言語プログラマがgolangの基本を押さえる為のまとめ - Qiita](https://qiita.com/tfrcm/items/e2a3d7ce7ab8868e37f7)

## 文法基礎

### パッケージ

- Goファイルは、何らかのパッケージに属する。

  ```go
  package パッケージ名
  ```

- 一つのディレクトリには、一つのパッケージのみ定義できる。

### インポート

- パッケージ名を上書きする場合

  ```go
  import 新しいパッケージ名 "パッケージ名"
  ```

- 使用時にパッケージ名を省略したい場合

  ```go
  import . "パッケージ名"
  ```

- 使用しないパッケージをインポートする場合

  ```go
  import _ "パッケージ名"
  ```

- パッケージ名の指定
  - 相対パス：import文が書かれたファイルからの相対パスで指定できる。（非推奨）
  - 絶対パス：環境変数`GOPATH`からの絶対パスで指定できる。

### スコープ

- Goにおけるスコープには、大きい順に以下のものがある。
  - パッケージ
  - ファイル
  - 関数
  - ブロック
  - 制御構文
- 関数外に定義されたものは、パッケージスコープとなる。
- パッケージスコープのうち、**識別子の1文字目が大文字**であるものは、他のパッケージからも参照できる。
- `import`文は、ファイルスコープとなる。
- `{処理}`とすると、関数内にブロックスコープを定義できる。

### その他

- Goプログラムは、`main`パッケージの`main`関数から開始される。
- 文はセミコロンで区切られるが、行末には（`{`や`,`で終わる場合を除いて）セミコロンが自動挿入され

## 変数

### 概要

- 変数の型は、値型・参照型・ポインタ型に分類される。

### 変数の定義

- 変数を定義する場合

  ```go
  var 変数名 型
  ```

- 複数の変数を同じ型で定義する場合

  ```go
  var 変数名1, 変数名2, ... 型
  ```

- 複数の変数を別の型で定義する場合

  ```go
  var (
    変数名1 型1
    変数名2 型2
    ...
  )
  ```

### 変数の代入

- 変数に代入する場合（再代入可能）

  ```go
  変数 = 値
  ```

- 複数の変数に代入する場合（再代入可能）

  ```go
  変数1, 変数2, ... = 値1, 値2, ...
  ```

### 変数の定義・代入

- 変数の定義と代入を行う場合（`var`を使う場合）

  ```go
  var 変数名 = 値
  ```

- 変数の定義と代入を行う場合（`:=`を使う場合）

  ```go
  変数名 := 値
  ```

- 複数の変数の定義と代入を行う場合（`var`を使う場合）

  ```go
  var (
    変数名1 = 値1
    変数名2 = 値2
    ...
  )
  ```

## 定数

### 定数の定義

- `var`句の代わりに`const`句を使うことで、定数を定義できる。

  ```go
  const 定数名 = 値
  ```

- `const`句で複数の定数を定義する際に、値が省略された場合は、前の定数の値が利用される。

### 定数の型

- 定数には、型なし定数（デフォルト）と型あり定数がある。
- 整数・浮動小数点数の定数は、最大値がなく、演算はコンパイル時に高精度に行われる。

### iota

- `iota`識別子は、インクリメントされる識別子である。
- `iota`識別子は、各`const`句で0から始まり、（使用されるか否かに関わらず）定数が定義されるたび1ずつ増加する。

## 関数

### 定義

- 一つの戻り値を返す場合

  ```go
  func 関数名(引数) 戻り値の型 {
    処理
  }
  ```

- 複数の戻り値を返す場合

  ```go
  func 関数名(引数) (戻り値の型1, 戻り値の型2, ...) {
    処理
  }
  ```

- 戻り値として変数を取ると、変数を自動で定義しreturnする。

  ```go
  func 関数名(引数) (変数名 変数の型) {
    処理
  }
  ```

- 戻り値の型を省略すると、他言語での`void`型となる。
- 関数名を省略し、無名関数とすることもできる。
- 引数として`_`を指定すると、引数を破棄できる。

### 呼び出し

- 複数の戻り値を受け取る場合

  ```go
  変数1, 変数2, ... = 関数名(引数)
  ```

- 受け取る変数として`_`を指定すると、戻り値を破棄できる。

### 関数の取り出し

- レシーバーを第1引数とする関数として取り出す場合

  ```go
  レシーバーの型.メソッド
  ```

### 例外

- Go言語では例外機構が存在しないので、戻り値としてエラーオブジェクト（`err`が慣例）を返すことが多い。

### 可変長引数

- 関数の引数として、`...変数`で可変長引数を定義できる。
- 関数呼び出し時、`スライス...`で、スライスを可変長引数として展開できる。

## メソッド

### 概要

- メソッドは、型に特化した関数のことである。

### 定義

- 書式

  ```go
  func (レシーバー レシーバーの型) 関数名(引数) 戻り値の型 {
    処理
  }
  ```

- 一般にレシーバーはポインタ型で定義する。

### 呼び出し

- メソッドを呼び出す場合

  ```go
  レシーバー.メソッド(引数)
  ```

- レシーバーは値型でもポインタ型でも、メソッドは区別せず呼び出せる。

### 関数の取り出し

- 下記書式で、メソッドを（レシーバーを第1引数とする）関数として取り出せる。

  ```go
  レシーバーの型.メソッド
  ```

## 制御構文

### if文

- 書式（丸括弧は不要で、波括弧は必要）

  ```go
  if [簡易文;] 条件 {
    処理
  }
  ```

- 簡易文は、制御構文内スコープで先に実行される。

### for文

- 書式

  ```go
  for [条件] {
    処理
  }
  ```

- 条件省略時は、無限ループとなる。

### for文（範囲式）

- 書式

  ```go
  for インデックス, 要素 := range 配列等 {
    処理
  }
  ```

- 範囲式で文字列を指定する場合、インデックスは文字数でなく**コードポイント**単位となる。

### 式によるswitch文

- `switch`文では、指定した式がcaseの値と等しい場合にそのcaseが実行される。

  ```go
  switch [簡易文;] [式] {
  case 値1:
    処理1
  case 値2:
    処理2
  ...
  default:
    処理
  }
  ```

- 式省略時は`true`となるため、各caseに真偽値を返す条件を書く。
- デフォルトではフォールスルー（次のcase節へ移る処理）は行われないが、`fallthrough`文で行うことができる。

### 型によるswitch文

- 型によるswitch文では、型アサーションと分岐を組み合わせた処理を記述できる。

  ```go
  switch [型変換後の値 :=] 変数.{型} {
  case 型1:
    処理1
  case 型2:
    処理2
  ...
  default:
    処理
  }
  ```

### defer

- `defer`文で、関数終了時に実行される関数呼び出しを定義できる。

  ```go
  defer 関数呼び出し
  ```

- `defer`文はいくつでも定義できるが、実行は**あとから定義された順**になされる。

### panic, recover

- `panic`関数を実行すると、（`defer`を実行後）ランタイムをエラー終了させる。
- `recover`関数は、`defer`文内で使い、ランタイムパニックによるプログラムの中断を回復する。

### go

- `go`文は、ゴルーチンを新たに作成してランタイムに追加する。

  ```go
  go 関数呼び出し
  ```

### init

- `init`関数で、`main`関数の前に実行される処理を定義できる。
- `init`関数では、引数も戻り値も定義しないようにする。
- `init`関数は複数定義でき、実行は定義した順になされる。

