# Go/文法/制御構造

## if

```go
if [簡易文;] 条件 {
  処理
}
```

- （制御構文内スコープで簡易文を実行したあと、）条件を満たす場合に、処理を実行する。

## 式によるswitch文

```go
switch [簡易文;] [式] {
case 値1:
  処理1
case 値2:
  処理2
...
default:
  処理
}
```

- 指定した式が値と等しい場合に、処理を実行する。
- 式省略時は`true`となるため、各caseに真偽値を返す条件を書く。
- デフォルトではフォールスルー（次のcase節へ移る処理）は行われないが、`fallthrough`文で行うことができる。

## 型によるswitch文

```go
switch [型変換後の値 :=] 変数.(type) {
case 型1:
  処理1
case 型2:
  処理2
...
default:
  処理
}
```

- 型アサーションを行い、その型が等しい場合に処理を実行する。

## for

```go
for [条件] {
  処理
}
```

- 条件省略時は、無限ループとなる。

## for文（範囲式）

```go
for インデックスまたはキー, 要素 := range 配列等 {
  処理
}
```

- 範囲式で文字列を指定する場合、インデックスは文字数でなく**コードポイント**単位となる。

- 要素を代入する変数は、**使い回される。**
  [Goのfor rangeでのポインタでハマったこと - Qiita](https://qiita.com/uchiko/items/1c611f0db618ce9dc0a9)

## contnue, break

| メソッド            | 概要                                                         |
| ------------------- | ------------------------------------------------------------ |
| `continue [ラベル]` | 指定したラベル（未指定時は今のfor文のループ）の次のループに移る。 |
| `break [ラベル]`    | 指定したラベル（未指定時は今のfor文のループ、またはswitch文）を抜ける。 |

## defer

- `defer`文で、関数終了時に実行される関数呼び出しを定義できる。

  ```go
  defer 関数呼び出し
  ```

- `defer`文はいくつでも定義できるが、実行は**あとから定義された順**になされる。

## panic, recover

- `panic`関数を実行すると、（`defer`を実行後）ランタイムをエラー終了させる。
- `recover`関数は、`defer`文内で使い、ランタイムパニックによるプログラムの中断を回復する。

## go

- `go`文は、ゴルーチンを新たに作成してランタイムに追加する。

  ```go
  go 関数呼び出し
  ```

## init

- `init`関数で、`main`関数の前に実行される処理を定義できる。
- `init`関数では、引数も戻り値も定義しないようにする。
- `init`関数は複数定義でき、実行は定義した順になされる。
